#include <pr2_torso_client.hh>


Torso::Torso(){
}
  
Torso::~Torso(){
  delete torso_client_;
}

  
void Torso::init(){    
    torso_client_ = new TorsoClient("torso_controller/position_joint_action", true);

    //wait for the action server to come up
    while(!torso_client_->waitForServer(ros::Duration(5.0))){
      ROS_INFO("Waiting for the torso action server to come up");
    }
  }

  // OPEN
actionlib::SimpleClientGoalState Torso::move_getState() {
  return torso_client_->getState();
}
void Torso::move_doneCb(const actionlib::SimpleClientGoalState& state,
	      const pr2_controllers_msgs::SingleJointPositionResultConstPtr& result)
  {
    // pr2_controllers_msgs/SingleJointPositionResult result
    ROS_INFO("Finished in state [%s]", state.toString().c_str());
  }
void Torso::move_activeCb()
  {
    ROS_INFO("Goal just went active");
  }
void Torso::move_feedbackCb(const pr2_controllers_msgs::SingleJointPositionFeedbackConstPtr& feedback)
  {
    // pr2_controllers_msgs/SingleJointPositionFeedback feedback
    ROS_INFO("Got Feedback\n");
  }
void Torso::move(pr2_controllers_msgs::SingleJointPositionGoal goal_cmd){
  // pr2_controllers_msgs::SingleJointPositionGoal 
  // float64 position
  // duration min_duration
  // float64 max_velocity
  if((goal_cmd.position<0) || (goal_cmd.position >=0.2) || (goal_cmd.min_duration <  ros::Duration(2.0)) || (goal_cmd.max_velocity > 1.0) || (goal_cmd.max_velocity < 0.0))
    {
    ROS_INFO("Move torso wrong param");
    }
  else
    {
    ROS_INFO("Sending move torso goal");
    torso_client_->sendGoal(goal_cmd, 
			    boost::bind(&Torso::move_doneCb, this, _1, _2), 
			    boost::bind(&Torso::move_activeCb, this),
			    boost::bind(&Torso::move_feedbackCb, this, _1));
    }
  }
void Torso::move_cancel(){
  torso_client_->cancelAllGoals();
}
